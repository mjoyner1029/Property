"""
The application factory for the Asset Anchor API.
Creates and configures Flask app with blueprints and extensions.
"""
from __future__ import annotations

import os
import uuid
import logging
import json
from typing import Optional, Dict, Any
from datetime import datetime

from flask import Flask, jsonify, request, current_app
from werkzeug.exceptions import HTTPException
from werkzeug.middleware.proxy_fix import ProxyFix
import traceback
import sentry_sdk
from sentry_sdk.integrations.flask import FlaskIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
from sentry_sdk.integrations.logging import LoggingIntegration
from jinja2 import TemplateNotFound
from sqlalchemy.exc import SQLAlchemyError

from .config import get_config, get_env_flag
from .extensions import (
    db,
    migrate,
    jwt,
    cors,
    talisman,
    socketio,
    mail,
    limiter,
    init_extensions
)


def create_app(config_name: Optional[str] = None) -> Flask:
    """
    Application factory function that creates and configures a Flask app.

    Args:
        config_name (str, optional): The name of the configuration to use.
            If None, will use APP_ENV environment variable. Defaults to None.

    Returns:
        Flask: The configured Flask application.
    
    Raises:
        ValueError: If required configuration is missing in production
    """
    app = Flask(__name__)
    
    # Disable strict slashes to avoid 308 redirects when URLs differ only by trailing slash
    app.url_map.strict_slashes = False

    # Load configuration
    try:
        config_obj = get_config(config_name)
        app.config.from_object(config_obj)
    except ValueError as e:
        app.logger.critical(f"Configuration error: {str(e)}")
        raise  # Re-raise to fail fast in production

    # Configure logging
    configure_logging(app)
    
    # Configure Sentry before other initialization to catch any errors
    configure_sentry(app)
    
    # Configure ProxyFix for proper IP handling behind proxies
    configure_proxy_fix(app)
    
    # Configure rate limiting settings from environment
    configure_rate_limiting(app)
    
    # Initialize extensions with the app
    init_extensions(app)

    # Register error handlers
    register_error_handlers(app)
    
    # Register health check endpoints
    register_health_checks(app)
    
    # Register blueprints
    register_blueprints(app)
    
    # Log application startup
    app.logger.info(f"Application started with {app.config.get('ENV')} configuration")

    # Force HTTPS in production
    if app.config.get("ENV") == "production":
        app.config['PREFERRED_URL_SCHEME'] = 'https'

    return app


def configure_rate_limiting(app: Flask) -> None:
    """
    Configure rate limiting settings from environment variables.
    Ensures tests have rate limiting disabled while production/dev have appropriate limits.
    
    Args:
        app: Flask application instance
    """
    # For testing, completely disable rate limiting
    if app.config.get("TESTING", False):
        app.config["RATELIMIT_ENABLED"] = False
        app.config["LIMITER_ENABLED"] = False
        app.config["FLASK_LIMITER_ENABLED"] = False
        app.config["RATELIMIT_STORAGE_URI"] = "memory://"
        app.config["RATELIMIT_STORAGE_URL"] = "memory://"
        app.config["RATELIMIT_DEFAULT"] = "10000 per second"
        # Also disable potential environment vars that might affect rate limiting
        os.environ["FLASK_LIMITER_ENABLED"] = "False"
        app.logger.info("Rate limiting is DISABLED for testing environment")
        return
    
    # For production/development, configure from environment
    default_limits = os.environ.get(
        "RATELIMIT_DEFAULT", 
        app.config.get("RATELIMIT_DEFAULT", "3000 per day, 1000 per hour, 100 per minute")
    )
    app.config["RATELIMIT_DEFAULT"] = default_limits
    
    # Use Redis for storage if available, otherwise memory
    storage_uri = os.environ.get(
        "RATELIMIT_STORAGE_URL", 
        app.config.get("REDIS_URL", "memory://")
    )
    app.config["RATELIMIT_STORAGE_URI"] = storage_uri
    app.config["RATELIMIT_STORAGE_URL"] = storage_uri
    
    # Other rate limiting config
    app.config["RATELIMIT_HEADERS_ENABLED"] = True
    app.config["RATELIMIT_SWALLOW_ERRORS"] = app.config.get("RATELIMIT_SWALLOW_ERRORS", True)
    app.config["RATELIMIT_KEY_PREFIX"] = app.config.get("RATELIMIT_KEY_PREFIX", "assetanchor")
    app.config["RATELIMIT_ENABLED"] = True
    
    app.logger.info(f"Rate limiting configured with default limits: {default_limits}")
    app.logger.info(f"Rate limiting storage: {storage_uri}")


def register_blueprints(app: Flask) -> None:
    """Register all Flask blueprints with standardized URL prefix structure."""
    # All API routes should be under /api
    API_PREFIX = '/api'
    
    # Feature flags for risk remediation - enable only completed modules
    ENABLE_AUTH = True
    ENABLE_CORE_API = True
    ENABLE_WEBHOOKS = True
    ENABLE_PAYMENTS = True
    ENABLE_PROPERTIES = True
    ENABLE_TENANTS = True
    ENABLE_MESSAGES = True
    ENABLE_NOTIFICATIONS = True
    ENABLE_ADMIN = True
    ENABLE_MFA = True
    ENABLE_DOCS = True
    
    blueprints = []
    
    # Authentication routes
    if ENABLE_AUTH:
        try:
            from .routes.auth_routes import bp as auth_bp
            blueprints.append((auth_bp, f'{API_PREFIX}/auth'))
            
            # MFA routes
            if ENABLE_MFA:
                try:
                    from .routes.mfa_routes import mfa_bp
                    blueprints.append((mfa_bp, f'{API_PREFIX}/auth/mfa'))
                except Exception as e:
                    app.logger.warning(f"Failed to load mfa_bp: {str(e)}")
        except Exception as e:
            app.logger.warning(f"Failed to load auth_bp: {str(e)}")
    
    # Core API routes
    if ENABLE_CORE_API:
        try:
            from .routes.api_routes import api_bp
            blueprints.append((api_bp, f'{API_PREFIX}'))
        except Exception as e:
            app.logger.warning(f"Failed to load api_bp: {str(e)}")
